#!/usr/bin/env python3
"""
Advantech Board Support Package (BSP) Registry Manager

This script provides a command-line interface for managing and building
Yocto-based BSPs using KAS build system. It supports Docker containers,
cached builds, and comprehensive configuration management.

Key Features:
- BSP registry management via YAML configuration
- Docker container building and management
- KAS build system integration
- Comprehensive error handling and validation
- Cache management for faster builds
- Environment variable configuration
"""

import subprocess
import os
import sys
import logging
import argparse
import dacite

import yaml
from pathlib import Path
from typing import List, Optional, Dict, Any

from dataclasses import dataclass, field

class ScriptError(Exception):
    """Base exception for all script-related errors."""
    pass

class ConfigurationError(ScriptError):
    """Raised when there are issues with configuration files or settings."""
    pass

class BuildError(ScriptError):
    """Raised when build processes fail."""
    pass

class DockerError(ScriptError):
    """Raised when Docker operations fail."""
    pass

class KasError(ScriptError):
    """Raised when KAS operations fail."""
    pass

def empty_list():
    """Factory function for creating empty lists in dataclass fields."""
    return []

@dataclass
class EnvironmentVariable:
    """Represents an environment variable name-value pair."""
    name: str
    value: str

@dataclass
class DockerArg:
    """Represents a Docker build argument (name=value pair)."""
    name: str
    value: str

@dataclass
class Docker:
    """Docker configuration for build environment."""
    image: Optional[str]  # Docker image name/tag
    file: Optional[str]   # Dockerfile path
    args: List[DockerArg] = field(default_factory=empty_list)  # Build arguments

@dataclass
class BuildEnvironment:
    """Build environment configuration including Docker settings."""
    docker: Docker

@dataclass
class BuildSetup:
    """Complete build setup configuration."""
    path: str                    # Build directory path
    environment: BuildEnvironment  # Build environment settings
    docker: Optional[str]        # Docker runtime to use
    configuration: List[str]     # KAS configuration files

@dataclass
class Specification:
    """Registry specification version."""
    version: str

@dataclass
class OperatingSystem:
    """Operating system configuration for the BSP."""
    name: str          # OS name (e.g., linux)
    build_system: str  # Build system (e.g., yocto)
    version: str       # OS version

@dataclass
class BSP:
    """Board Support Package definition."""
    name: str           # BSP identifier
    description: str    # Human-readable description
    os: OperatingSystem # OS configuration
    build: BuildSetup   # Build configuration

@dataclass
class Registry:
    """Main registry containing BSP definitions."""
    bsp: Optional[List[BSP]] = field(default_factory=empty_list)  # BSP definitions

@dataclass
class RegistryRoot:
    """Root container for the registry configuration."""
    specification: Specification  # Specification version
    registry: Registry           # Main registry data
    environment: Optional[List[EnvironmentVariable]] = field(default_factory=empty_list)  # Environment variables

def read_yaml_file(filename: Path) -> str:
    """
    Read a YAML file into a string.
    
    Args:
        filename: Path to the YAML file
        
    Returns:
        String containing file contents
        
    Raises:
        SystemExit: If file cannot be read
    """
    try:
        with open(filename, 'r', encoding='utf-8') as yaml_file:
            return yaml_file.read()
    except (IOError, OSError) as e:
        logging.error(f"Failed to read YAML file {filename}: {e}")
        sys.exit(1)

def parse_yaml_file(yaml_string: str) -> Dict[Any, Any]:
    """
    Parse YAML string into a python dictionary.
    
    Args:
        yaml_string: YAML formatted string
        
    Returns:
        Dictionary representation of YAML content
        
    Raises:
        SystemExit: If YAML parsing fails
    """
    try:
        return yaml.safe_load(yaml_string)
    except yaml.YAMLError as e:
        logging.error(f"Failed to parse YAML: {e}")
        sys.exit(1)

def get_registry_from_yaml_file(filename: Path) -> RegistryRoot:
    """
    Parse YAML file into structured RegistryRoot object.
    
    Args:
        filename: Path to registry YAML file
        
    Returns:
        Structured registry configuration
        
    Raises:
        SystemExit: If configuration is invalid or malformed
    """
    yaml_string = read_yaml_file(filename)
    yaml_dict = parse_yaml_file(yaml_string)

    try:
        # Use dacite to convert dictionary to strongly-typed dataclass
        cfg = dacite.Config(strict=False)  # Allow unknown fields for forward compatibility
        ast = dacite.from_dict(data_class=RegistryRoot, data=yaml_dict, config=cfg)
        return ast
    except dacite.UnexpectedDataError as e:
        logging.error(f"Configuration error in {filename}: {e}")
        sys.exit(1)
    except dacite.WrongTypeError as e:
        logging.error(f"Type error in configuration {filename}: {e}")
        sys.exit(1)
    except dacite.MissingValueError as e:
        logging.error(f"Missing value in configuration {filename}: {e}")
        sys.exit(1)

def build_docker(dockerfile_dir: str, dockerfile: str, tag: str, build_args: Optional[List[DockerArg]] = None) -> None:
    """
    Build Docker image from Dockerfile.
    
    Args:
        dockerfile_dir: Directory containing Dockerfile
        dockerfile: Dockerfile name
        tag: Image tag for the built image
        build_args: List of Docker build arguments
        
    Raises:
        SystemExit: If Docker build fails or prerequisites are missing
    """
    logging.info(f"Building docker container {tag} using {dockerfile}")
    
    # Validate prerequisites
    if not os.path.isdir(dockerfile_dir):
        logging.error(f"Docker build directory does not exist: {dockerfile_dir}")
        sys.exit(1)
        
    dockerfile_path = os.path.join(dockerfile_dir, dockerfile)
    if not os.path.isfile(dockerfile_path):
        logging.error(f"Dockerfile not found: {dockerfile_path}")
        sys.exit(1)

    original_dir = os.getcwd()
    try:
        # Change to Dockerfile directory for context
        os.chdir(dockerfile_dir)
        
        # Build docker command
        cmd = ["docker", "build", "-f", dockerfile, "-t", tag]
        
        # Add build arguments if provided
        if build_args:
            for argument in build_args:
                cmd.extend(["--build-arg", f"{argument.name}={argument.value}"])

        cmd.extend(["."])  # Build context is current directory
        
        logging.info(f"Running: {' '.join(cmd)}")
        
        # Execute build command
        process = subprocess.run(cmd, check=True, capture_output=True, text=True)
        logging.info("Docker build completed successfully")
        
    except subprocess.CalledProcessError as e:
        logging.error(f"Docker build failed with return code {e.returncode}")
        logging.error(f"Error output: {e.stderr}")
        sys.exit(1)
    except Exception as e:
        logging.error(f"Unexpected error during Docker build: {e}")
        sys.exit(1)
    finally:
        # Always return to original directory
        os.chdir(original_dir)

class PathResolver:
    """
    Utility class for path resolution and validation.
    
    Provides methods to resolve paths with home directory expansion
    and validate path existence and types.
    """
    
    @staticmethod
    def resolve(path_string: str) -> Path:
        """Resolve path with ~ expansion to Path object."""
        return Path(path_string).expanduser().resolve()
    
    @staticmethod
    def resolve_str(path_string: str) -> str:
        """Resolve path with ~ expansion to string."""
        return str(PathResolver.resolve(path_string))
    
    @staticmethod
    def exists(path_string: str) -> bool:
        """Check if path exists (after resolving ~)."""
        return PathResolver.resolve(path_string).exists()
    
    @staticmethod
    def is_file(path_string: str) -> bool:
        """Check if path is a file (after resolving ~)."""
        return PathResolver.resolve(path_string).is_file()
    
    @staticmethod
    def is_dir(path_string: str) -> bool:
        """Check if path is a directory (after resolving ~)."""
        return PathResolver.resolve(path_string).is_dir()
    
    @staticmethod
    def ensure_directory(path_string: str) -> None:
        """
        Ensure directory exists, create if necessary.
        
        Args:
            path_string: Directory path to ensure
            
        Raises:
            SystemExit: If directory cannot be created
        """
        path = PathResolver.resolve(path_string)
        try:
            path.mkdir(parents=True, exist_ok=True)
        except (OSError, IOError) as e:
            logging.error(f"Failed to create directory {path}: {e}")
            sys.exit(1)

# Global path resolver instance
resolver = PathResolver()

class EnvironmentManager:
    """
    Manager for environment variable configuration.
    
    Handles environment variable setup and validation for build environments.
    """
    
    def __init__(self, environment_vars: Optional[List[EnvironmentVariable]] = None):
        """
        Initialize Environment manager.
        
        Args:
            environment_vars: List of environment variables to manage
        """
        self.environment_vars = environment_vars or []
        self._env_dict = self._build_environment_dict()
        
    def _build_environment_dict(self) -> Dict[str, str]:
        """Build a dictionary from the environment variable list."""
        env_dict = {}
        for env_var in self.environment_vars:
            env_dict[env_var.name] = env_var.value
        return env_dict
    
    def get_environment_dict(self) -> Dict[str, str]:
        """Get environment variables as a dictionary."""
        return self._env_dict.copy()
    
    def get_value(self, key: str, default: Optional[str] = None) -> Optional[str]:
        """Get the value of an environment variable by key."""
        return self._env_dict.get(key, default)
    
    def validate_environment(self) -> bool:
        """
        Validate that all environment variable paths exist.
        
        Returns:
            True if all paths are valid, False otherwise
        """
        # Check common path variables
        path_variables = ['DL_DIR', 'SSTATE_DIR', 'GITCONFIG_FILE']
        
        for var_name in path_variables:
            if var_name in self._env_dict:
                path_value = self._env_dict[var_name]
                if not resolver.exists(path_value):
                    logging.warning(f"Environment variable {var_name} path does not exist: {path_value}")
                    # Don't exit here, just warn - paths might be created later
        
        logging.info(f"Environment configuration validated with {len(self._env_dict)} variables")
        return True
        
    def setup_environment(self, base_env: Dict[str, str]) -> Dict[str, str]:
        """
        Set up environment variables for build processes.
        
        Args:
            base_env: Base environment dictionary
            
        Returns:
            Updated environment with configured variables
        """
        env = base_env.copy()
        
        # Add all configured environment variables
        for env_var in self.environment_vars:
            env[env_var.name] = env_var.value
            logging.debug(f"Set {env_var.name}={env_var.value}")
            
        return env

class KasManager:
    """
    Manager for KAS (KAS is Yet Another Build System for Yocto) operations.
    
    This class handles KAS configuration validation, build execution,
    and environment management with comprehensive error handling.
    """
    
    def __init__(self, kas_files: List[str], build_dir: str = "build", use_container: bool = False,
                 download_dir: str = None, sstate_dir: str = None,
                 container_engine: str = None, container_image: str = None,
                 search_paths: List[str] = None, env_manager: EnvironmentManager = None):
        """
        Initialize KAS manager with configuration.
        
        Args:
            kas_files: List of KAS configuration files
            build_dir: Build output directory
            use_container: Use kas-container instead of native kas
            download_dir: Downloads cache directory
            sstate_dir: Shared state cache directory
            container_engine: Docker or podman
            container_image: Custom container image
            search_paths: Additional paths to search for configuration files
            env_manager: Environment configuration manager
            
        Raises:
            SystemExit: If initialization fails
        """
        if not isinstance(kas_files, list) or not kas_files:
            logging.error("kas_files must be a non-empty list of file paths")
            sys.exit(1)

        self.kas_files = kas_files
        self.build_dir = Path(build_dir).resolve()
        self.use_container = use_container
        self.container_engine = container_engine
        self.container_image = container_image
        self.search_paths = search_paths or []
        self.download_dir = download_dir
        self.sstate_dir = sstate_dir
        self.env_manager = env_manager or EnvironmentManager()

        # Add common search paths for configuration files
        self.search_paths.extend([
            str(Path.cwd()),              # Current working directory
            str(self.build_dir),          # Build directory
            str(Path(__file__).parent),   # Script directory
            "/repo",                      # Common container path
            "/repo/examples",             # Examples in container
        ])

        self.original_cwd = Path.cwd()
        self._yaml_cache = {}  # Cache for parsed YAML files

        # Ensure build directory exists
        resolver.ensure_directory(str(self.build_dir))

    def _get_kas_command(self) -> List[str]:
        """Get the appropriate KAS command (native or container)."""
        if self.use_container:
            return ["kas-container"]
        else:
            return ["kas"]

    def _get_environment_with_container_vars(self) -> dict:
        """
        Prepare environment variables for KAS execution.
        
        Returns:
            Environment dictionary with KAS-specific variables
        """
        env = os.environ.copy()

        # Set cache directories if provided (override environment manager if specified)
        if self.download_dir:
            env['DL_DIR'] = self.download_dir
        elif not env.get('DL_DIR'):  # Only set from env_manager if not already set
            dl_dir = self.env_manager.get_value('DL_DIR')
            if dl_dir:
                env['DL_DIR'] = dl_dir
                
        if self.sstate_dir:
            env["SSTATE_DIR"] = self.sstate_dir
        elif not env.get('SSTATE_DIR'):  # Only set from env_manager if not already set
            sstate_dir = self.env_manager.get_value('SSTATE_DIR')
            if sstate_dir:
                env['SSTATE_DIR'] = sstate_dir

        # Set container-specific environment variables
        if self.use_container:
            if self.container_engine:
                env['KAS_CONTAINER_ENGINE'] = self.container_engine
            if self.container_image:
                env['KAS_CONTAINER_IMAGE'] = self.container_image

        # Apply environment manager configuration (overrides any previous settings)
        env = self.env_manager.setup_environment(env)

        return env

    def _resolve_kas_file(self, kas_file: str) -> str:
        """
        Resolve KAS file path to absolute path.
        
        Searches in multiple locations:
        - Absolute path
        - Relative to current directory
        - Relative to build directory
        - Script directory
        - Custom search paths
        
        Args:
            kas_file: KAS file path to resolve
            
        Returns:
            Absolute path to KAS file
            
        Raises:
            SystemExit: If file cannot be found in any search location
        """
        path = Path(kas_file)

        # Check absolute path
        if path.is_absolute() and path.exists():
            return str(path.resolve())

        # Check relative to current working directory
        if path.exists():
            return str(path.resolve())

        # Check relative to build directory
        build_dir_path = self.build_dir / path
        if build_dir_path.exists():
            return str(build_dir_path.resolve())

        # Check relative to script directory
        script_dir_path = Path(__file__).parent / path
        if script_dir_path.exists():
            return str(script_dir_path.resolve())

        # Check additional search paths
        for search_path in self.search_paths:
            search_path_obj = Path(search_path)
            candidate_path = search_path_obj / path
            if candidate_path.exists():
                return str(candidate_path.resolve())

        # File not found in any location
        logging.error(f"KAS file not found: {kas_file}")
        logging.error(f"Searched in: {', '.join(self.search_paths)}")
        sys.exit(1)

    def _find_file_in_search_paths(self, filename: str) -> Optional[str]:
        """Find a file in the configured search paths."""
        # Check absolute path
        if Path(filename).is_absolute() and Path(filename).exists():
            return str(Path(filename).resolve())

        # Check relative to current directory
        if Path(filename).exists():
            return str(Path(filename).resolve())

        # Check all search paths
        for search_path in self.search_paths:
            candidate = Path(search_path) / filename
            if candidate.exists():
                return str(candidate.resolve())

        return None

    def _get_kas_files_string(self) -> str:
        """Convert list of KAS files to colon-delimited string with resolved paths."""
        resolved_files = [self._resolve_kas_file(f) for f in self.kas_files]
        return ":".join(resolved_files)

    def _parse_yaml_file(self, file_path: str) -> Dict[str, Any]:
        """
        Parse YAML file with caching.
        
        Args:
            file_path: Path to YAML file
            
        Returns:
            Parsed YAML content as dictionary
            
        Raises:
            SystemExit: If file cannot be parsed
        """
        resolved_path = self._resolve_kas_file(file_path)
        if resolved_path in self._yaml_cache:
            return self._yaml_cache[resolved_path]

        try:
            with open(resolved_path, 'r', encoding='utf-8') as f:
                content = yaml.safe_load(f) or {}
                self._yaml_cache[resolved_path] = content
                return content
        except (yaml.YAMLError, IOError) as e:
            logging.error(f"Failed to parse YAML file {file_path}: {e}")
            sys.exit(1)

    def _find_includes_in_yaml(self, yaml_content: Dict[str, Any]) -> List[str]:
        """
        Extract include files from YAML content.
        
        KAS configuration files can include other files through:
        - Top-level 'includes' key
        - 'header' -> 'includes' nested key
        
        Args:
            yaml_content: Parsed YAML content
            
        Returns:
            List of include file paths
        """
        includes = []

        # Check top-level includes
        if 'includes' in yaml_content:
            include_list = yaml_content['includes']
            if isinstance(include_list, list):
                includes.extend(include_list)

        # Check header includes (less common)
        if 'header' in yaml_content and 'includes' in yaml_content['header']:
            header_includes = yaml_content['header']['includes']
            if isinstance(header_includes, list):
                includes.extend(header_includes)

        return includes

    def _resolve_include_path(self, include_file: str, parent_file: str) -> str:
        """
        Resolve include file path relative to its parent file.
        
        Args:
            include_file: Include file path (may be relative)
            parent_file: Parent file path for relative resolution
            
        Returns:
            Absolute path to include file
            
        Raises:
            SystemExit: If include file cannot be found
        """
        # Absolute paths are used as-is
        if include_file.startswith('/'):
            return include_file

        # First try relative to parent file directory
        parent_dir = Path(parent_file).parent
        relative_path = parent_dir / include_file
        if relative_path.exists():
            return str(relative_path.resolve())

        # Search in all configured paths
        found_path = self._find_file_in_search_paths(include_file)
        if found_path:
            return found_path

        # Include file not found
        logging.error(f"Include file not found: {include_file} (referenced from {parent_file})")
        sys.exit(1)

    def _get_all_included_files(self, main_files: List[str]) -> List[str]:
        """
        Recursively find all included files from main KAS files.
        
        Performs depth-first search to build complete dependency tree.
        
        Args:
            main_files: List of main KAS configuration files
            
        Returns:
            Flat list of all files in dependency order
            
        Raises:
            SystemExit: If any included file is missing
        """
        all_files = []
        processed_files = set()

        def process_file(file_path: str):
            """Recursive function to process files and their includes."""
            if file_path in processed_files:
                return

            resolved_path = self._resolve_kas_file(file_path)
            if resolved_path in processed_files:
                return

            processed_files.add(resolved_path)

            # Verify file exists
            if not Path(resolved_path).exists():
                logging.error(f"File not found: {file_path} (resolved to: {resolved_path})")
                sys.exit(1)

            # Parse file and find includes
            yaml_content = self._parse_yaml_file(file_path)
            includes = self._find_includes_in_yaml(yaml_content)
            
            # Process includes first (depth-first)
            for include in includes:
                include_path = self._resolve_include_path(include, file_path)
                process_file(include_path)

            # Add current file after its includes
            all_files.append(file_path)

        # Process all main files
        for main_file in main_files:
            process_file(main_file)

        return all_files

    def validate_kas_files(self, check_includes: bool = True) -> bool:
        """
        Validate that all KAS configuration files exist.
        
        Args:
            check_includes: Whether to recursively validate include files
            
        Returns:
            True if validation succeeds
            
        Raises:
            SystemExit: If any file is missing
        """
        try:
            # Check main files
            for kas_file in self.kas_files:
                self._resolve_kas_file(kas_file)  # Will exit if file not found

            # Recursively check include files if requested
            if check_includes:
                self._get_all_included_files(self.kas_files)
                logging.info("All KAS files validated successfully")

            return True

        except SystemExit:
            # Re-raise system exit exceptions
            raise
        except Exception as e:
            logging.error(f"KAS file validation failed: {e}")
            sys.exit(1)

    def check_kas_available(self) -> bool:
        """
        Check if KAS or kas-container is installed and available.
        
        Returns:
            True if KAS is available, False otherwise
        """
        kas_cmd = self._get_kas_command()
        env = self._get_environment_with_container_vars()
        
        try:
            if self.use_container:
                # For container version, check if help command works
                test_cmd = kas_cmd + ["--help"]
                result = subprocess.run(
                    test_cmd,
                    check=False,
                    capture_output=True,
                    text=True,
                    timeout=30,
                    env=env
                )
                return result.returncode == 0 or len(result.stdout) > 0 or len(result.stderr) > 0
            else:
                # For native version, check version command
                test_cmd = kas_cmd + ["--version"]
                result = subprocess.run(test_cmd, check=True, capture_output=True, timeout=30, env=env)
                return True
        except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired) as e:
            logging.error(f"KAS command not available: {e}")
            return False

    def _run_kas_command(self, args: List[str], show_output: bool = True) -> subprocess.CompletedProcess:
        """
        Execute KAS command with proper environment and error handling.
        
        Args:
            args: Command arguments to pass to KAS
            show_output: Whether to show live output or capture it
            
        Returns:
            Completed process information
            
        Raises:
            SystemExit: If command fails or is interrupted
        """
        cmd = self._get_kas_command() + args
        env = self._get_environment_with_container_vars()

        logging.info(f"Running: {' '.join(cmd)}")
        logging.info(f"Build directory: {self.build_dir}")
        logging.info(f"Using container: {self.use_container}")

        # Log important environment variables
        important_vars = ['DL_DIR', 'SSTATE_DIR', 'GITCONFIG_FILE']
        for var in important_vars:
            if var in env:
                logging.info(f"Using {var}: {env[var]}")

        try:
            if show_output:
                # Show live output to console
                result = subprocess.run(
                    cmd,
                    check=True,
                    cwd=self.build_dir,
                    env=env
                )
            else:
                # Capture output for programmatic use
                result = subprocess.run(
                    cmd,
                    check=True,
                    cwd=self.build_dir,
                    capture_output=True,
                    text=True,
                    env=env
                )
            return result
            
        except subprocess.CalledProcessError as e:
            logging.error(f"KAS command failed with return code {e.returncode}")
            if not show_output and e.stderr:
                logging.error(f"Error output: {e.stderr}")
            sys.exit(1)
        except KeyboardInterrupt:
            logging.error("Command interrupted by user")
            sys.exit(1)

    def build_project(self, target: str = None, task: str = None, show_output: bool = True) -> None:
        """
        Build the Yocto project using KAS.
        
        Args:
            target: Specific build target
            task: Specific build task
            show_output: Whether to show build output
            
        Raises:
            SystemExit: If build fails or prerequisites are not met
        """
        # Validate environment configuration first
        if not self.env_manager.validate_environment():
            logging.error("Environment configuration validation failed")
            sys.exit(1)

        # Validate configuration files
        if not self.validate_kas_files(check_includes=True):
            logging.error("Cannot build due to missing files")
            sys.exit(1)

        # Check KAS availability
        if not self.check_kas_available():
            logging.error("KAS is not available. Please install with: pip install kas")
            sys.exit(1)

        # Build KAS command arguments
        kas_files_str = self._get_kas_files_string()
        args = ["build", kas_files_str]

        if target:
            args.extend(["--target", target])
        if task:
            args.extend(["--task", task])

        try:
            self._run_kas_command(args, show_output)
            logging.info("Build completed successfully!")
        except SystemExit:
            raise
        except Exception as e:
            logging.error(f"Build failed: {e}")
            sys.exit(1)

    def shell_session(self, command: str = None, show_output: bool = True) -> None:
        """
        Start KAS shell session or execute command in build environment.
        
        Args:
            command: Optional command to execute in shell
            show_output: Whether to show command output
            
        Raises:
            SystemExit: If shell session fails
        """
        if not self.validate_kas_files(check_includes=True):
            sys.exit(1)

        if not self.check_kas_available():
            logging.error("KAS is not available")
            sys.exit(1)

        kas_files_str = self._get_kas_files_string()
        args = ["shell", kas_files_str]

        if command:
            args.extend(["--command", command])

        try:
            self._run_kas_command(args, show_output)
        except SystemExit:
            raise
        except Exception as e:
            logging.error(f"Shell session failed: {e}")
            sys.exit(1)

    def run_bitbake_command(self, recipe: str, bitbake_args: List[str] = None, show_output: bool = True) -> None:
        """
        Run BitBake command through KAS shell.
        
        Args:
            recipe: BitBake recipe to build
            bitbake_args: Additional BitBake arguments
            show_output: Whether to show command output
            
        Raises:
            SystemExit: If BitBake command fails
        """
        if not self.validate_kas_files(check_includes=True):
            sys.exit(1)

        if not self.check_kas_available():
            logging.error("KAS is not available")
            sys.exit(1)

        # Build BitBake command
        bitbake_cmd = ["bitbake", recipe]
        if bitbake_args:
            bitbake_cmd.extend(bitbake_args)

        # Execute through KAS shell
        kas_files_str = self._get_kas_files_string()
        args = ["shell", kas_files_str, "--command", " ".join(bitbake_cmd)]

        logging.info(f"Running BitBake: {' '.join(bitbake_cmd)}")

        try:
            self._run_kas_command(args, show_output)
            logging.info("BitBake command completed successfully!")
        except SystemExit:
            raise
        except Exception as e:
            logging.error(f"BitBake command failed: {e}")
            sys.exit(1)

    def dump_config(self, show_output: bool = True) -> Optional[str]:
        """
        Dump expanded KAS configuration for verification.
        
        Args:
            show_output: Whether to show output or return it
            
        Returns:
            Configuration string if show_output=False, None otherwise
            
        Raises:
            SystemExit: If config dump fails
        """
        if not self.validate_kas_files(check_includes=True):
            sys.exit(1)

        if not self.check_kas_available():
            logging.error("KAS is not available")
            sys.exit(1)

        kas_files_str = self._get_kas_files_string()
        args = ["dump", kas_files_str]

        try:
            if show_output:
                self._run_kas_command(args, show_output=True)
                return None
            else:
                result = self._run_kas_command(args, show_output=False)
                return result.stdout
        except SystemExit:
            raise
        except Exception as e:
            logging.error(f"Config dump failed: {e}")
            sys.exit(1)

class Application:
    """
    Main application class for BSP registry management.
    
    This class coordinates the overall application flow including
    configuration loading, BSP management, and build execution.
    """
    
    def __init__(self, config_path: str = "bsp-registry.yml"):
        """
        Initialize application.
        
        Args:
            config_path: Path to BSP registry configuration file
        """
        self.config_path = Path(config_path)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.model = None  # Will hold parsed registry configuration
        self.env_manager = None  # Environment configuration manager

    def load_configuration(self) -> None:
        """
        Load and parse application configuration from YAML file.
        
        Raises:
            SystemExit: If configuration file is missing or invalid
        """
        try:
            if not self.config_path.exists():
                logging.error(f"Config file not found: {self.config_path}")
                sys.exit(1)

            # Parse YAML configuration into structured model
            self.model = get_registry_from_yaml_file(self.config_path)
            logging.info(f"Configuration loaded successfully from {self.config_path}")

            # Initialize Environment manager if configuration exists
            if self.model.environment:
                self.env_manager = EnvironmentManager(self.model.environment)
                logging.info(f"Environment configuration initialized with {len(self.model.environment)} variables")

        except SystemExit:
            raise
        except Exception as e:
            logging.error(f"Failed to load configuration: {e}")
            sys.exit(1)

    def initialize(self) -> None:
        """Initialize application components."""
        logging.info("Initializing application...")
        self.load_configuration()
        
        # Validate environment configuration if present
        if self.env_manager:
            if not self.env_manager.validate_environment():
                logging.error("Environment configuration validation failed")
                sys.exit(1)
                
        logging.info("Application initialized successfully")

    def list_bsp(self) -> None:
        """
        List all available BSPs in the registry.
        
        Raises:
            SystemExit: If no BSPs are found in registry
        """
        if not self.model or not self.model.registry.bsp:
            logging.error("No BSPs found in registry")
            sys.exit(1)

        logging.info("Available BSPs:")
        for bsp in self.model.registry.bsp:
            print(f"- {bsp.name}: {bsp.description}")

    def get_bsp_by_name(self, bsp_name: str) -> BSP:
        """
        Retrieve BSP configuration by name.
        
        Args:
            bsp_name: Name of the BSP to retrieve
            
        Returns:
            BSP configuration object
            
        Raises:
            SystemExit: If BSP with given name is not found
        """
        for bsp in self.model.registry.bsp:
            if bsp.name == bsp_name:
                return bsp
        
        # BSP not found - show error with available options
        logging.error(f"BSP not found: {bsp_name}")
        logging.info("Available BSPs:")
        for bsp in self.model.registry.bsp:
            logging.info(f"  - {bsp.name}")
        sys.exit(1)

    def prepare_build_directory(self, build_path: str) -> None:
        """
        Prepare build directory, creating it if necessary.
        
        Args:
            build_path: Path to build directory
            
        Raises:
            SystemExit: If directory cannot be created
        """
        logging.info(f"Preparing build directory: {build_path}")
        resolver.ensure_directory(build_path)

    def build_bsp_with_kas(self, configuration: List[str], build_path: str, docker_image: str) -> None:
        """
        Execute KAS build for a BSP.
        
        Args:
            configuration: List of KAS configuration files
            build_path: Build output directory
            docker_image: Docker image to use for build
            
        Raises:
            SystemExit: If build fails
        """
        # Get cache directories from environment manager
        downloads = None
        sstate = None
        
        if self.env_manager:
            downloads = self.env_manager.get_value('DL_DIR')
            sstate = self.env_manager.get_value('SSTATE_DIR')

        # Ensure cache directories exist if specified
        if downloads:
            resolver.ensure_directory(downloads)
        if sstate:
            resolver.ensure_directory(sstate)

        # Initialize KAS manager with environment configuration
        kas_mgr = KasManager(
            configuration, 
            build_path, 
            download_dir=downloads, 
            sstate_dir=sstate, 
            use_container=True, 
            container_image=docker_image,
            env_manager=self.env_manager  # Pass environment manager to KAS
        )

        # Dump configuration for verification (debugging)
        config_output = kas_mgr.dump_config(show_output=False)
        if config_output:
            logging.debug("Configuration dump:")
            logging.debug(config_output)

        # Execute build
        kas_mgr.build_project()

    def build_bsp(self, bsp_name: str) -> None:
        """
        Build a specific BSP including Docker image and Yocto build.
        
        Args:
            bsp_name: Name of the BSP to build
            
        Raises:
            SystemExit: If any step of the build process fails
        """
        logging.info(f"Building BSP: {bsp_name}")
        
        # Retrieve BSP configuration
        bsp = self.get_bsp_by_name(bsp_name)
        
        logging.info(f"Building {bsp.name} - {bsp.description}")
        
        # Build Docker image if configured
        if (bsp.build.environment.docker.file and 
            bsp.build.environment.docker.image):
            build_docker(
                ".", 
                bsp.build.environment.docker.file, 
                bsp.build.environment.docker.image, 
                bsp.build.environment.docker.args
            )
        
        # Prepare build directory
        self.prepare_build_directory(bsp.build.path)
        
        # Execute KAS build
        self.build_bsp_with_kas(
            configuration=bsp.build.configuration,
            build_path=bsp.build.path,
            docker_image=bsp.build.environment.docker.image
        )
        
        logging.info(f"BSP {bsp_name} built successfully!")

    def cleanup(self) -> None:
        """Cleanup resources and perform any necessary finalization."""
        logging.debug("Cleaning up resources...")
        # Add cleanup logic here if needed (e.g., temp files, connections)

def main() -> int:
    """
    Main entry point for the BSP registry manager.
    
    Returns:
        Exit code (0 for success, non-zero for errors)
    """
    try:
        # Parse command line arguments
        parser = argparse.ArgumentParser(description="Advantech Board Support Package Registry")
        parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
        parser.add_argument('--registry', '-r', default='bsp-registry.yml', help='BSP Registry file')

        # Create subparsers for different commands
        subparsers = parser.add_subparsers(dest='command', help='Command to execute', required=True)

        # Build command
        build_parser = subparsers.add_parser('build', help='Build an image for BSP')
        build_parser.add_argument(
            'bsp_name',
            type=str,
            help='Name of the BSP to build'
        )
        build_parser.add_argument(
            '--clean',
            action='store_true',
            help='Clean before building'
        )

        # List command
        list_parser = subparsers.add_parser('list', help='List available BSPs')

        # Export command (stub implementation)
        export_parser = subparsers.add_parser('export', help='Export BSP configuration')
        export_parser.add_argument('bsp_name', type=str, help='Name of the BSP')
        export_parser.add_argument('--format', type=str, help='Export to format (KAS, Repo)')

        # Shell command (stub implementation)            
        shell_parser = subparsers.add_parser('shell', help='Enter bitbake shell for BSP')
        shell_parser.add_argument('bsp_name', type=str, help='Name of the BSP')

        args = parser.parse_args()

        # Setup logging based on verbosity
        log_level = logging.DEBUG if args.verbose else logging.INFO
        logging.basicConfig(
            level=log_level,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )

        # Initialize and run application
        app = Application(args.registry)
        app.initialize()

        # Execute requested command
        if args.command == 'build':
            app.build_bsp(args.bsp_name)
        elif args.command == 'list':
            app.list_bsp()
        else:
            # For unimplemented commands, validate BSP exists and show message
            logging.warning(f"Command {args.command} not fully implemented yet")
            if hasattr(args, 'bsp_name'):
                app.get_bsp_by_name(args.bsp_name)
                logging.info(f"Command {args.command} would proceed with BSP {args.bsp_name}")

        app.cleanup()
        logging.info("Command completed successfully")
        return 0

    except KeyboardInterrupt:
        logging.info("Application interrupted by user")
        return 130  # Standard exit code for SIGINT
    except SystemExit as e:
        # Re-raise system exit with proper code
        return e.code if isinstance(e.code, int) else 1
    except Exception as e:
        logging.error(f"Fatal error: {e}")
        return 1

if __name__ == "__main__":
    # Execute main function and exit with proper code
    sys.exit(main())