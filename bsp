#!/usr/bin/env python3

import subprocess
import os
import sys
import logging
import argparse
import dacite

import yaml
from pathlib import Path
from typing import List, Optional, Dict, Any

from dataclasses import dataclass, field

class ScriptError(Exception):
    """Base exception for script errors."""
    pass

class ConfigurationError(ScriptError):
    """Configuration related errors."""
    pass

class BuildError(ScriptError):
    """Build related errors."""
    pass

class DockerError(ScriptError):
    """Docker related errors."""
    pass

class KasError(ScriptError):
    """KAS related errors."""
    pass

# shortcut to reduce code duplication for default_factory
def empty_list():
    return []

@dataclass
class DockerArg:
    name: str
    value: str

@dataclass
class Docker:
    image: Optional[str]
    file: Optional[str]
    args: List[DockerArg] = field(default_factory=empty_list)

@dataclass
class BuildEnvironment:
    docker: Docker

@dataclass
class BuildSetup:
    path: str
    environment: BuildEnvironment
    docker: Optional[str]
    configuration: List[str]

@dataclass
class Specification:
    version: str

@dataclass
class OperatingSystem:
    name: str
    build_system: str
    version: str

@dataclass
class BSP:
    name: str
    description: str
    os: OperatingSystem
    build: BuildSetup

@dataclass
class BuildCache:
    sstate: str
    downloads: str

@dataclass
class Registry:
    cache: BuildCache
    includes: Optional[List[Path]] = field(default_factory=empty_list)
    bsp: Optional[List[BSP]] = field(default_factory=empty_list)

@dataclass
class RegistryRoot:
    specification: Specification
    registry: Registry

def read_yaml_file(filename: Path) -> str:
    """
    Read a YAML file into a string.
    Exits on error.
    """
    try:
        with open(filename, 'r', encoding='utf-8') as yaml_file:
            return yaml_file.read()
    except (IOError, OSError) as e:
        logging.error(f"Failed to read YAML file {filename}: {e}")
        sys.exit(1)

def parse_yaml_file(yaml_string: str) -> Dict[Any, Any]:
    """
    Parse YAML string into a python dictionary.
    Exits on error.
    """
    try:
        return yaml.safe_load(yaml_string)
    except yaml.YAMLError as e:
        logging.error(f"Failed to parse YAML: {e}")
        sys.exit(1)

def get_registry_from_yaml_file(filename: Path) -> RegistryRoot:
    """
    Reads a YAML file and returns AST.
    Exits on error.
    """
    yaml_string = read_yaml_file(filename)
    yaml_dict = parse_yaml_file(yaml_string)

    try:
        cfg = dacite.Config(strict=False)
        ast = dacite.from_dict(data_class=RegistryRoot, data=yaml_dict, config=cfg)
        return ast
    except dacite.UnexpectedDataError as e:
        logging.error(f"Configuration error in {filename}: {e}")
        sys.exit(1)
    except dacite.WrongTypeError as e:
        logging.error(f"Type error in configuration {filename}: {e}")
        sys.exit(1)
    except dacite.MissingValueError as e:
        logging.error(f"Missing value in configuration {filename}: {e}")
        sys.exit(1)

def build_docker(dockerfile_dir: str, dockerfile: str, tag: str, build_args: Optional[List[DockerArg]] = None) -> None:
    """
    Build Docker image using subprocess.
    Exits on error.
    """
    logging.info(f"Building docker container {tag} using {dockerfile}")
    
    if not os.path.isdir(dockerfile_dir):
        logging.error(f"Docker build directory does not exist: {dockerfile_dir}")
        sys.exit(1)
        
    dockerfile_path = os.path.join(dockerfile_dir, dockerfile)
    if not os.path.isfile(dockerfile_path):
        logging.error(f"Dockerfile not found: {dockerfile_path}")
        sys.exit(1)

    original_dir = os.getcwd()
    try:
        os.chdir(dockerfile_dir)
        
        cmd = ["docker", "build", "-f", dockerfile, "-t", tag]
        
        if build_args:
            for argument in build_args:
                cmd.extend(["--build-arg", f"{argument.name}={argument.value}"])

        cmd.extend(["."])
        
        logging.info(f"Running: {' '.join(cmd)}")
        
        process = subprocess.run(cmd, check=True, capture_output=True, text=True)
        logging.info("Docker build completed successfully")
        
    except subprocess.CalledProcessError as e:
        logging.error(f"Docker build failed with return code {e.returncode}")
        logging.error(f"Error output: {e.stderr}")
        sys.exit(1)
    except Exception as e:
        logging.error(f"Unexpected error during Docker build: {e}")
        sys.exit(1)
    finally:
        os.chdir(original_dir)

class PathResolver:
    """Utility class for path resolution and validation."""
    
    @staticmethod
    def resolve(path_string: str) -> Path:
        """Resolve path with ~ to Path object."""
        return Path(path_string).expanduser().resolve()
    
    @staticmethod
    def resolve_str(path_string: str) -> str:
        """Resolve path with ~ to string."""
        return str(PathResolver.resolve(path_string))
    
    @staticmethod
    def exists(path_string: str) -> bool:
        """Check if path exists (after resolving ~)."""
        return PathResolver.resolve(path_string).exists()
    
    @staticmethod
    def is_file(path_string: str) -> bool:
        """Check if path is a file (after resolving ~)."""
        return PathResolver.resolve(path_string).is_file()
    
    @staticmethod
    def is_dir(path_string: str) -> bool:
        """Check if path is a directory (after resolving ~)."""
        return PathResolver.resolve(path_string).is_dir()
    
    @staticmethod
    def ensure_directory(path_string: str) -> None:
        """Ensure directory exists, create if not. Exit on error."""
        path = PathResolver.resolve(path_string)
        try:
            path.mkdir(parents=True, exist_ok=True)
        except (OSError, IOError) as e:
            logging.error(f"Failed to create directory {path}: {e}")
            sys.exit(1)

resolver = PathResolver()

class KasManager:
    """
    Manager for KAS build operations with comprehensive error handling.
    Exits on critical errors.
    """
    
    def __init__(self, kas_files: List[str], build_dir: str = "build", use_container: bool = False,
                 download_dir: str = None, sstate_dir: str = None,
                 container_engine: str = None, container_image: str = None,
                 search_paths: List[str] = None):
        """
        Initialize KAS manager with list of configuration files.
        Exits on invalid input.
        """
        if not isinstance(kas_files, list) or not kas_files:
            logging.error("kas_files must be a non-empty list of file paths")
            sys.exit(1)

        self.kas_files = kas_files
        self.build_dir = Path(build_dir).resolve()
        self.use_container = use_container
        self.container_engine = container_engine
        self.container_image = container_image
        self.search_paths = search_paths or []
        self.download_dir = download_dir
        self.sstate_dir = sstate_dir

        # Add common search paths
        self.search_paths.extend([
            str(Path.cwd()),
            str(self.build_dir),
            str(Path(__file__).parent),
            "/repo",
            "/repo/examples",
        ])

        self.original_cwd = Path.cwd()
        self._yaml_cache = {}

        # Ensure build directory exists
        resolver.ensure_directory(str(self.build_dir))

    def _get_kas_command(self) -> List[str]:
        """Get the appropriate KAS command (native or container)."""
        if self.use_container:
            return ["kas-container"]
        else:
            return ["kas"]

    def _get_environment_with_container_vars(self) -> dict:
        """Get environment variables with container settings."""
        env = os.environ.copy()

        if self.download_dir:
            env['DL_DIR'] = self.download_dir
        if self.sstate_dir:
            env["SSTATE_DIR"] = self.sstate_dir

        if self.use_container:
            if self.container_engine:
                env['KAS_CONTAINER_ENGINE'] = self.container_engine
            if self.container_image:
                env['KAS_CONTAINER_IMAGE'] = self.container_image

        return env

    def _resolve_kas_file(self, kas_file: str) -> str:
        """
        Resolve a KAS file path to absolute path.
        Exits if file cannot be found.
        """
        path = Path(kas_file)

        if path.is_absolute() and path.exists():
            return str(path.resolve())

        # Check relative to current working directory
        if path.exists():
            return str(path.resolve())

        # Check if file exists relative to build directory
        build_dir_path = self.build_dir / path
        if build_dir_path.exists():
            return str(build_dir_path.resolve())

        # Check if file exists relative to script directory
        script_dir_path = Path(__file__).parent / path
        if script_dir_path.exists():
            return str(script_dir_path.resolve())

        # Check additional search paths
        for search_path in self.search_paths:
            search_path_obj = Path(search_path)
            candidate_path = search_path_obj / path
            if candidate_path.exists():
                return str(candidate_path.resolve())

        logging.error(f"KAS file not found: {kas_file}")
        logging.error(f"Searched in: {', '.join(self.search_paths)}")
        sys.exit(1)

    def _find_file_in_search_paths(self, filename: str) -> Optional[str]:
        """Find a file in the search paths."""
        if Path(filename).is_absolute() and Path(filename).exists():
            return str(Path(filename).resolve())

        if Path(filename).exists():
            return str(Path(filename).resolve())

        for search_path in self.search_paths:
            candidate = Path(search_path) / filename
            if candidate.exists():
                return str(candidate.resolve())

        return None

    def _get_kas_files_string(self) -> str:
        """Convert list of KAS files to colon-delimited string with resolved paths."""
        resolved_files = [self._resolve_kas_file(f) for f in self.kas_files]
        return ":".join(resolved_files)

    def _parse_yaml_file(self, file_path: str) -> Dict[str, Any]:
        """Parse a YAML file with caching. Exit on error."""
        resolved_path = self._resolve_kas_file(file_path)
        if resolved_path in self._yaml_cache:
            return self._yaml_cache[resolved_path]

        try:
            with open(resolved_path, 'r', encoding='utf-8') as f:
                content = yaml.safe_load(f) or {}
                self._yaml_cache[resolved_path] = content
                return content
        except (yaml.YAMLError, IOError) as e:
            logging.error(f"Failed to parse YAML file {file_path}: {e}")
            sys.exit(1)

    def _find_includes_in_yaml(self, yaml_content: Dict[str, Any]) -> List[str]:
        """Extract include files from YAML content."""
        includes = []

        if 'includes' in yaml_content:
            include_list = yaml_content['includes']
            if isinstance(include_list, list):
                includes.extend(include_list)

        if 'header' in yaml_content and 'includes' in yaml_content['header']:
            header_includes = yaml_content['header']['includes']
            if isinstance(header_includes, list):
                includes.extend(header_includes)

        return includes

    def _resolve_include_path(self, include_file: str, parent_file: str) -> str:
        """Resolve an include file path relative to its parent file."""
        if include_file.startswith('/'):
            return include_file

        parent_dir = Path(parent_file).parent
        relative_path = parent_dir / include_file
        if relative_path.exists():
            return str(relative_path.resolve())

        found_path = self._find_file_in_search_paths(include_file)
        if found_path:
            return found_path

        logging.error(f"Include file not found: {include_file} (referenced from {parent_file})")
        sys.exit(1)

    def _get_all_included_files(self, main_files: List[str]) -> List[str]:
        """
        Recursively find all included files from the main KAS files.
        Returns a flat list of all files in dependency order.
        Exits on missing files.
        """
        all_files = []
        processed_files = set()

        def process_file(file_path: str):
            if file_path in processed_files:
                return

            resolved_path = self._resolve_kas_file(file_path)
            if resolved_path in processed_files:
                return

            processed_files.add(resolved_path)

            if not Path(resolved_path).exists():
                logging.error(f"File not found: {file_path} (resolved to: {resolved_path})")
                sys.exit(1)

            yaml_content = self._parse_yaml_file(file_path)
            includes = self._find_includes_in_yaml(yaml_content)
            
            for include in includes:
                include_path = self._resolve_include_path(include, file_path)
                process_file(include_path)

            all_files.append(file_path)

        for main_file in main_files:
            process_file(main_file)

        return all_files

    def validate_kas_files(self, check_includes: bool = True) -> bool:
        """Validate that all KAS configuration files exist, including includes."""
        try:
            # Check main files
            for kas_file in self.kas_files:
                self._resolve_kas_file(kas_file)  # This will exit if file not found

            # Check include files if requested
            if check_includes:
                self._get_all_included_files(self.kas_files)
                logging.info("All KAS files validated successfully")

            return True

        except SystemExit:
            # Re-raise system exit exceptions
            raise
        except Exception as e:
            logging.error(f"KAS file validation failed: {e}")
            sys.exit(1)

    def check_kas_available(self) -> bool:
        """Check if kas or kas-container is installed and available."""
        kas_cmd = self._get_kas_command()
        env = self._get_environment_with_container_vars()
        
        try:
            if self.use_container:
                test_cmd = kas_cmd + ["--help"]
                result = subprocess.run(
                    test_cmd,
                    check=False,
                    capture_output=True,
                    text=True,
                    timeout=30,
                    env=env
                )
                return result.returncode == 0 or len(result.stdout) > 0 or len(result.stderr) > 0
            else:
                test_cmd = kas_cmd + ["--version"]
                result = subprocess.run(test_cmd, check=True, capture_output=True, timeout=30, env=env)
                return True
        except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired) as e:
            logging.error(f"KAS command not available: {e}")
            return False

    def _run_kas_command(self, args: List[str], show_output: bool = True) -> subprocess.CompletedProcess:
        """Internal method to run KAS commands with proper output handling."""
        cmd = self._get_kas_command() + args
        env = self._get_environment_with_container_vars()

        logging.info(f"Running: {' '.join(cmd)}")
        logging.info(f"Build directory: {self.build_dir}")
        logging.info(f"Using container: {self.use_container}")

        try:
            if show_output:
                result = subprocess.run(
                    cmd,
                    check=True,
                    cwd=self.build_dir,
                    env=env
                )
            else:
                result = subprocess.run(
                    cmd,
                    check=True,
                    cwd=self.build_dir,
                    capture_output=True,
                    text=True,
                    env=env
                )
            return result
            
        except subprocess.CalledProcessError as e:
            logging.error(f"KAS command failed with return code {e.returncode}")
            if not show_output and e.stderr:
                logging.error(f"Error output: {e.stderr}")
            sys.exit(1)
        except KeyboardInterrupt:
            logging.error("Command interrupted by user")
            sys.exit(1)

    def build_project(self, target: str = None, task: str = None, show_output: bool = True) -> None:
        """Build the Yocto project with multiple KAS files. Exit on error."""
        if not self.validate_kas_files(check_includes=True):
            logging.error("Cannot build due to missing files")
            sys.exit(1)

        if not self.check_kas_available():
            logging.error("KAS is not available. Please install with: pip install kas")
            sys.exit(1)

        kas_files_str = self._get_kas_files_string()
        args = ["build", kas_files_str]

        if target:
            args.extend(["--target", target])
        if task:
            args.extend(["--task", task])

        try:
            self._run_kas_command(args, show_output)
            logging.info("Build completed successfully!")
        except SystemExit:
            raise
        except Exception as e:
            logging.error(f"Build failed: {e}")
            sys.exit(1)

    def shell_session(self, command: str = None, show_output: bool = True) -> None:
        """Start kas shell or run specific command with multiple KAS files. Exit on error."""
        if not self.validate_kas_files(check_includes=True):
            sys.exit(1)

        if not self.check_kas_available():
            logging.error("KAS is not available")
            sys.exit(1)

        kas_files_str = self._get_kas_files_string()
        args = ["shell", kas_files_str]

        if command:
            args.extend(["--command", command])

        try:
            self._run_kas_command(args, show_output)
        except SystemExit:
            raise
        except Exception as e:
            logging.error(f"Shell session failed: {e}")
            sys.exit(1)

    def run_bitbake_command(self, recipe: str, bitbake_args: List[str] = None, show_output: bool = True) -> None:
        """Run a specific BitBake command with live output. Exit on error."""
        if not self.validate_kas_files(check_includes=True):
            sys.exit(1)

        if not self.check_kas_available():
            logging.error("KAS is not available")
            sys.exit(1)

        bitbake_cmd = ["bitbake", recipe]
        if bitbake_args:
            bitbake_cmd.extend(bitbake_args)

        kas_files_str = self._get_kas_files_string()
        args = ["shell", kas_files_str, "--command", " ".join(bitbake_cmd)]

        logging.info(f"Running BitBake: {' '.join(bitbake_cmd)}")

        try:
            self._run_kas_command(args, show_output)
            logging.info("BitBake command completed successfully!")
        except SystemExit:
            raise
        except Exception as e:
            logging.error(f"BitBake command failed: {e}")
            sys.exit(1)

    def dump_config(self, show_output: bool = True) -> Optional[str]:
        """Dump the expanded configuration from multiple files. Exit on error."""
        if not self.validate_kas_files(check_includes=True):
            sys.exit(1)

        if not self.check_kas_available():
            logging.error("KAS is not available")
            sys.exit(1)

        kas_files_str = self._get_kas_files_string()
        args = ["dump", kas_files_str]

        try:
            if show_output:
                self._run_kas_command(args, show_output=True)
                return None
            else:
                result = self._run_kas_command(args, show_output=False)
                return result.stdout
        except SystemExit:
            raise
        except Exception as e:
            logging.error(f"Config dump failed: {e}")
            sys.exit(1)

class Application:
    """Main application class with comprehensive error handling."""

    def __init__(self, config_path: str = "bsp-registry.yml"):
        self.config_path = Path(config_path)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.model = None

    def load_configuration(self) -> None:
        """Load application configuration. Exit on error."""
        try:
            if not self.config_path.exists():
                logging.error(f"Config file not found: {self.config_path}")
                sys.exit(1)

            self.model = get_registry_from_yaml_file(self.config_path)
            logging.info(f"Configuration loaded successfully from {self.config_path}")

        except SystemExit:
            raise
        except Exception as e:
            logging.error(f"Failed to load configuration: {e}")
            sys.exit(1)

    def initialize(self) -> None:
        """Initialize application components. Exit on error."""
        logging.info("Initializing application...")
        self.load_configuration()
        logging.info("Application initialized successfully")

    def list_bsp(self) -> None:
        """List available BSPs. Exit on error."""
        if not self.model or not self.model.registry.bsp:
            logging.error("No BSPs found in registry")
            sys.exit(1)

        logging.info("Available BSPs:")
        for bsp in self.model.registry.bsp:
            print(f"- {bsp.name}: {bsp.description}")

    def get_bsp_by_name(self, bsp_name: str) -> BSP:
        """Get BSP by name. Exit if not found."""
        for bsp in self.model.registry.bsp:
            if bsp.name == bsp_name:
                return bsp
        
        logging.error(f"BSP not found: {bsp_name}")
        logging.info("Available BSPs:")
        for bsp in self.model.registry.bsp:
            logging.info(f"  - {bsp.name}")
        sys.exit(1)

    def prepare_build_directory(self, build_path: str) -> None:
        """Prepare build directory. Exit on error."""
        logging.info(f"Preparing build directory: {build_path}")
        resolver.ensure_directory(build_path)

    def build_bsp_with_kas(self, configuration: List[str], downloads: str, sstate: str, 
                          build_path: str, docker_image: str) -> None:
        """Build BSP using KAS. Exit on error."""
        # Ensure cache directories exist
        resolver.ensure_directory(downloads)
        resolver.ensure_directory(sstate)

        kas_mgr = KasManager(
            configuration, 
            build_path, 
            download_dir=downloads, 
            sstate_dir=sstate, 
            use_container=True, 
            container_image=docker_image
        )

        # Dump configuration for verification
        config_output = kas_mgr.dump_config(show_output=False)
        if config_output:
            logging.debug("Configuration dump:")
            logging.debug(config_output)

        # Build the project
        kas_mgr.build_project()

    def build_bsp(self, bsp_name: str) -> None:
        """Build a specific BSP. Exit on any error."""
        logging.info(f"Building BSP: {bsp_name}")
        
        bsp = self.get_bsp_by_name(bsp_name)
        
        logging.info(f"Building {bsp.name} - {bsp.description}")
        
        # Build Docker image if specified
        if (bsp.build.environment.docker.file and 
            bsp.build.environment.docker.image):
            build_docker(
                ".", 
                bsp.build.environment.docker.file, 
                bsp.build.environment.docker.image, 
                bsp.build.environment.docker.args
            )
        
        # Prepare build directory
        self.prepare_build_directory(bsp.build.path)
        
        # Build with KAS
        self.build_bsp_with_kas(
            configuration=bsp.build.configuration,
            build_path=bsp.build.path,
            downloads=self.model.registry.cache.downloads,
            sstate=self.model.registry.cache.sstate,
            docker_image=bsp.build.environment.docker.image
        )
        
        logging.info(f"BSP {bsp_name} built successfully!")

    def cleanup(self) -> None:
        """Cleanup resources."""
        logging.debug("Cleaning up resources...")
        # Add cleanup logic here if needed

def main() -> int:
    """Main entry point with comprehensive error handling."""
    try:
        # Parse arguments
        parser = argparse.ArgumentParser(description="Advantech Board Support Package Registry")
        parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
        parser.add_argument('--registry', '-r', default='bsp-registry.yml', help='BSP Registry file')

        subparsers = parser.add_subparsers(dest='command', help='Command to execute', required=True)

        # Build command
        build_parser = subparsers.add_parser('build', help='Build an image for BSP')
        build_parser.add_argument(
            'bsp_name',
            type=str,
            help='Name of the BSP to build'
        )
        build_parser.add_argument(
            '--clean',
            action='store_true',
            help='Clean before building'
        )

        # List command
        list_parser = subparsers.add_parser('list', help='List available BSPs')

        # Export command (stub)
        export_parser = subparsers.add_parser('export', help='Export BSP configuration')
        export_parser.add_argument('bsp_name', type=str, help='Name of the BSP')
        export_parser.add_argument('--format', type=str, help='Export to format (KAS, Repo)')

        # Shell command (stub)            
        shell_parser = subparsers.add_parser('shell', help='Enter bitbake shell for BSP')
        shell_parser.add_argument('bsp_name', type=str, help='Name of the BSP')

        args = parser.parse_args()

        # Setup logging
        log_level = logging.DEBUG if args.verbose else logging.INFO
        logging.basicConfig(
            level=log_level,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )

        # Initialize application
        app = Application(args.registry)
        app.initialize()

        # Execute command
        if args.command == 'build':
            app.build_bsp(args.bsp_name)
        elif args.command == 'list':
            app.list_bsp()
        else:
            logging.warning(f"Command {args.command} not fully implemented yet")
            # For unimplemented commands, just show we found the BSP
            if hasattr(args, 'bsp_name'):
                app.get_bsp_by_name(args.bsp_name)
                logging.info(f"Command {args.command} would proceed with BSP {args.bsp_name}")

        app.cleanup()
        logging.info("Command completed successfully")
        return 0

    except KeyboardInterrupt:
        logging.info("Application interrupted by user")
        return 130
    except SystemExit as e:
        return e.code if isinstance(e.code, int) else 1
    except Exception as e:
        logging.error(f"Fatal error: {e}")
        return 1

if __name__ == "__main__":
    sys.exit(main())